<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>图片的懒加载</title>
</head>
<body>
    <div>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事1111111111</p>
        <img data-src='http://img.netbian.com/file/2020/1204/1d56070cb14657d8bc6612d61f1a3070.jpg'/>
        <img data-src='http://img.netbian.com/file/20110216/75b2226da46ba59be670ee2bdbedd665.jpg'/>
        <img data-src='http://img.netbian.com/file/2020/1204/1d56070cb14657d8bc6612d61f1a3070.jpg'/>
        <img data-src='http://img.netbian.com/file/20110216/75b2226da46ba59be670ee2bdbedd665.jpg'/>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
        <p>如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事</p>
    </div>
    <script>
        //窗口的显示区的高度
        //图片到视窗上面的距离，可以用元素的getBoundingClintRect().top来获取
        const images = document.querySelectorAll('img')

        /**如果页面需要加载很多内容就会导致人物的堆积，而且即使图片已经加载了，还是会不断触发事件
        window.addEventListener('scroll', (e) => { 
            images.forEach(image => {
                const  imageTop = image.getBoundingClientRect().top
                if (imageTop < window.innerHeight) {
                    const data_src = image.getAttribute('data-src')
                    image.setAttribute('src', data_src)
                }
            })
        })
        */

        //推荐使用IntersectionObserver:浏览器提供的构造函数，目标元素和可视窗口会产生交叉区域,它接收的第一个参数是callback，
        //目标元素能看见触发一次，目标元素看不见了触发一次
        const callback = (entries) => { //回调函数接受一个参数，这个参数是一个数组
            entries.forEach(entry => {
                if (entry.isIntersecting) { //如果被观察到了
                    const image = entry.target
                    const data_src = image.getAttribute('data-src')
                    image.setAttribute('src', data_src)
                    observer.unobserve(image)
                    console.log('触发了');
                }
            })
        }
        const observer = new IntersectionObserver(callback)
        images.forEach(image => {
            observer.observe(image) //观察每一个image节点
        })
    </script>
</body>
</html>